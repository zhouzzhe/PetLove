"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _noop2 = _interopRequireDefault(require("lodash/noop"));
var _find2 = _interopRequireDefault(require("lodash/find"));
var _get2 = _interopRequireDefault(require("lodash/get"));
var _merge2 = _interopRequireDefault(require("lodash/merge"));
var _react = _interopRequireWildcard(require("react"));
var _classnames = require("@douyinfe/semi-foundation/lib/cjs/utils/classnames");
var _constants = require("@douyinfe/semi-foundation/lib/cjs/table/constants");
var _utils = require("@douyinfe/semi-foundation/lib/cjs/table/utils");
var _Table = _interopRequireDefault(require("./Table"));
var _utils2 = require("./utils");
var _getColumns = _interopRequireDefault(require("./getColumns"));
var _ResizableHeaderCell = _interopRequireDefault(require("./ResizableHeaderCell"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/* eslint-disable react-hooks/exhaustive-deps */

const ResizableTable = function () {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let ref = arguments.length > 1 ? arguments[1] : undefined;
  const {
      components: propComponents,
      columns: propColumns,
      resizable
    } = props,
    restProps = __rest(props, ["components", "columns", "resizable"]);
  const childrenColumnName = 'children';
  const onResize = (0, _get2.default)(resizable, 'onResize', _noop2.default);
  const onResizeStart = (0, _get2.default)(resizable, 'onResizeStart', _noop2.default);
  const onResizeStop = (0, _get2.default)(resizable, 'onResizeStop', _noop2.default);
  /**
   * 此处关于 columns 有三个存储
   *
   * 1. rawColumns 是根据 props.columns 或者 props.children 解析出来的原始 columns
   * 2. newColumns 是 rawColumns 的深拷贝，同时根据 props.expandedRowRender、props.hideExpandedColumn 和 props.rowSelection
   * 这三个参数加入了【选择列】以及【展开列】
   * 3. columns 是当前组件中存储的 state，一般情况下与 newColumns 相等，但是会保存列当前伸缩的宽度
   */
  /**
    * There are three stores for columns here
    *
    * 1. rawColumns are the original columns parsed according to props.columns or props.children
    * 2. newColumns is a deep copy of rawColumns, based on props.expandedRowRender, props.hideExpandedColumn and props.rowSelection
    * These three parameters have been added [Select Column] and [Expand Column]
    * 3. columns is the state stored in the current component, which is generally equal to newColumns, but it will save the current stretched width of the column
    */
  const parsedColumns = Array.isArray(propColumns) && propColumns.length ? propColumns : (0, _getColumns.default)(props.children);
  const rawColumns = (0, _utils.assignColumnKeys)((0, _utils2.cloneDeep)(parsedColumns), childrenColumnName);
  const newColumns = (0, _utils.assignColumnKeys)((0, _utils2.cloneDeep)(parsedColumns), childrenColumnName);
  if (typeof props.expandedRowRender === 'function' && !props.hideExpandedColumn && !(0, _find2.default)(rawColumns, item => item.key === _constants.strings.DEFAULT_KEY_COLUMN_EXPAND)) {
    newColumns.unshift({
      key: _constants.strings.DEFAULT_KEY_COLUMN_EXPAND,
      width: _constants.numbers.DEFAULT_WIDTH_COLUMN_EXPAND
    });
  }
  if (props.rowSelection && !(0, _get2.default)(props.rowSelection, 'hidden') && !(0, _find2.default)(rawColumns, item => item.key === _constants.strings.DEFAULT_KEY_COLUMN_SELECTION)) {
    newColumns.unshift({
      width: (0, _get2.default)(props, 'rowSelection.width', _constants.numbers.DEFAULT_WIDTH_COLUMN_SELECTION),
      key: _constants.strings.DEFAULT_KEY_COLUMN_SELECTION
    });
  }
  const [columns, setColumns] = (0, _react.useState)(newColumns);
  (0, _react.useEffect)(() => {
    // If there is a resize value, the width does not use the default value fix#1072
    const _newColumns = (0, _utils.withResizeWidth)(columns, newColumns);
    setColumns((0, _utils2.mergeColumns)(columns, _newColumns));
  }, [propColumns, props.expandedRowRender, props.hideExpandedColumn, props.rowSelection]);
  const components = (0, _react.useMemo)(() => (0, _merge2.default)({
    header: {
      cell: _ResizableHeaderCell.default
    }
  }, propComponents), [propComponents]);
  const handlerClassName = (0, _get2.default)(resizable, 'handlerClassName', 'resizing');
  const handleResize = column => (e, _ref) => {
    let {
      size
    } = _ref;
    const nextColumns = (0, _utils2.cloneDeep)(columns);
    const curColumn = (0, _utils.findColumn)(nextColumns, column, childrenColumnName);
    let nextColumn = Object.assign(Object.assign({}, curColumn), {
      width: size.width
    });
    const customProps = onResize(nextColumn) || {};
    nextColumn = Object.assign(Object.assign({}, nextColumn), customProps);
    Object.assign(curColumn, nextColumn);
    setColumns(nextColumns);
  };
  const handleResizeStart = column => e => {
    const nextColumns = (0, _utils2.cloneDeep)(columns);
    const curColumn = (0, _utils.findColumn)(nextColumns, column, childrenColumnName);
    let nextColumn = Object.assign(Object.assign({}, curColumn), {
      className: (0, _classnames.addClass)(curColumn.className, handlerClassName)
    });
    const customProps = onResizeStart(nextColumn) || {};
    nextColumn = Object.assign(Object.assign({}, nextColumn), customProps);
    Object.assign(curColumn, nextColumn);
    setColumns(nextColumns);
  };
  const handleResizeStop = column => e => {
    const nextColumns = (0, _utils2.cloneDeep)(columns);
    const curColumn = (0, _utils.findColumn)(nextColumns, column, childrenColumnName);
    let nextColumn = Object.assign(Object.assign({}, curColumn), {
      className: (0, _classnames.removeClass)(curColumn.className, handlerClassName)
    });
    const customProps = onResizeStop(nextColumn) || {};
    nextColumn = Object.assign(Object.assign({}, nextColumn), customProps);
    Object.assign(curColumn, nextColumn);
    setColumns(nextColumns);
  };
  const resizableRender = function (col, index) {
    let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let originalHeaderCellProps = arguments.length > 3 ? arguments[3] : undefined;
    return Object.assign(Object.assign({}, col), {
      onHeaderCell: column => {
        return Object.assign(Object.assign({}, originalHeaderCellProps), {
          width: column.width,
          onResize: handleResize(column),
          onResizeStart: handleResizeStart(column),
          onResizeStop: handleResizeStop(column)
        });
      }
    });
  };
  const assignResizableRender = function () {
    let columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return Array.isArray(columns) && columns.length ? columns.map((col, index) => {
      var _a, _b;
      const originalHeaderCellProps = (_b = (_a = col.onHeaderCell) === null || _a === void 0 ? void 0 : _a.call(col, col, index, level)) !== null && _b !== void 0 ? _b : {};
      Object.assign(col, resizableRender(col, index, level, originalHeaderCellProps));
      const children = col[childrenColumnName];
      if (Array.isArray(children) && children.length) {
        col[childrenColumnName] = assignResizableRender(children, level + 1);
      }
      return col;
    }) : [];
  };
  const finalColumns = (0, _react.useMemo)(() => assignResizableRender(columns), [columns]);
  return /*#__PURE__*/_react.default.createElement(_Table.default, Object.assign({}, restProps, {
    columns: finalColumns,
    components: components,
    ref: ref
  }));
};
var _default = exports.default = /*#__PURE__*/_react.default.forwardRef(ResizableTable);