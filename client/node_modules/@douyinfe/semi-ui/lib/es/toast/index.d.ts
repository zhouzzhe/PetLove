import React, { CSSProperties } from 'react';
import PropTypes from 'prop-types';
import { ToastListAdapter, ToastListProps, ToastListState } from '@douyinfe/semi-foundation/lib/es/toast/toastListFoundation';
import '@douyinfe/semi-foundation/lib/es/toast/toast.css';
import useToast from './useToast';
import { ConfigProps, ToastInstance, ToastProps, ToastState } from '@douyinfe/semi-foundation/lib/es/toast/toastFoundation';
export interface ToastReactProps extends ToastProps {
    id?: string;
    style?: CSSProperties;
    icon?: React.ReactNode;
    content: React.ReactNode;
}
export type { ConfigProps, ToastListProps, ToastListState, ToastState };
declare const createBaseToast: () => {
    new (props: ToastListProps): {
        stack: boolean;
        innerWrapperRef: React.RefObject<HTMLDivElement>;
        readonly adapter: ToastListAdapter;
        handleMouseEnter: (e: React.MouseEvent) => void;
        handleMouseLeave: (e: React.MouseEvent) => void;
        has(id: string): any;
        add(opts: ToastInstance): any;
        update(id: string, opts: ToastInstance): any;
        remove(id: string): any;
        destroyAll(): any;
        render(): React.JSX.Element;
        cache: any;
        foundation: any;
        componentDidMount(): void;
        componentWillUnmount(): void;
        isControlled: (key: any) => boolean;
        log(text: string, ...rest: any): any;
        getDataAttr(props?: any): {};
        setStateAsync: (state: Partial<ToastListState>) => Promise<void>;
        context: unknown;
        setState<K extends keyof ToastListState>(state: ToastListState | ((prevState: Readonly<ToastListState>, props: Readonly<ToastListProps>) => ToastListState | Pick<ToastListState, K>) | Pick<ToastListState, K>, callback?: () => void): void;
        forceUpdate(callback?: () => void): void;
        readonly props: Readonly<ToastListProps>;
        state: Readonly<ToastListState>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ToastListProps>, prevState: Readonly<ToastListState>): any;
        componentDidUpdate?(prevProps: Readonly<ToastListProps>, prevState: Readonly<ToastListState>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ToastListProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ToastListProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): void;
    };
    ref: {
        stack: boolean;
        innerWrapperRef: React.RefObject<HTMLDivElement>;
        readonly adapter: ToastListAdapter;
        handleMouseEnter: (e: React.MouseEvent) => void;
        handleMouseLeave: (e: React.MouseEvent) => void;
        has(id: string): any;
        add(opts: ToastInstance): any;
        update(id: string, opts: ToastInstance): any;
        remove(id: string): any;
        destroyAll(): any;
        render(): React.JSX.Element;
        cache: any;
        foundation: any;
        componentDidMount(): void;
        componentWillUnmount(): void;
        isControlled: (key: any) => boolean;
        log(text: string, ...rest: any): any;
        getDataAttr(props?: any): {};
        setStateAsync: (state: Partial<ToastListState>) => Promise<void>;
        context: unknown;
        setState<K extends keyof ToastListState>(state: ToastListState | ((prevState: Readonly<ToastListState>, props: Readonly<ToastListProps>) => ToastListState | Pick<ToastListState, K>) | Pick<ToastListState, K>, callback?: () => void): void;
        forceUpdate(callback?: () => void): void;
        readonly props: Readonly<ToastListProps>;
        state: Readonly<ToastListState>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ToastListProps>, prevState: Readonly<ToastListState>): any;
        componentDidUpdate?(prevProps: Readonly<ToastListProps>, prevState: Readonly<ToastListState>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ToastListProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ToastListProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): void;
    };
    useToast: typeof useToast;
    defaultOpts: ToastReactProps & {
        motion: boolean;
    };
    propTypes: {
        content: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        duration: PropTypes.Requireable<number>;
        onClose: PropTypes.Requireable<(...args: any[]) => any>;
        icon: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        direction: PropTypes.Requireable<string>;
        stack: PropTypes.Requireable<boolean>;
    };
    defaultProps: {};
    wrapperId: null | string;
    create(opts: ToastReactProps): string;
    close(id: string): void;
    destroyAll(): void;
    getWrapperId(): string;
    info(opts: Omit<ToastReactProps, 'type'> | string): string;
    warning(opts: Omit<ToastReactProps, 'type'> | string): string;
    error(opts: Omit<ToastReactProps, 'type'> | string): string;
    success(opts: Omit<ToastReactProps, 'type'> | string): string;
    config(opts: ConfigProps): void;
    contextType?: React.Context<any>;
};
export declare class ToastFactory {
    static create(config?: ConfigProps): ReturnType<typeof createBaseToast>;
}
declare const _default: {
    new (props: ToastListProps): {
        stack: boolean;
        innerWrapperRef: React.RefObject<HTMLDivElement>;
        readonly adapter: ToastListAdapter;
        handleMouseEnter: (e: React.MouseEvent<Element, MouseEvent>) => void;
        handleMouseLeave: (e: React.MouseEvent<Element, MouseEvent>) => void;
        has(id: string): any;
        add(opts: ToastInstance): any;
        update(id: string, opts: ToastInstance): any;
        remove(id: string): any;
        destroyAll(): any;
        render(): React.JSX.Element;
        cache: any;
        foundation: any;
        componentDidMount(): void;
        componentWillUnmount(): void;
        isControlled: (key: any) => boolean;
        log(text: string, ...rest: any): any;
        getDataAttr(props?: any): {};
        setStateAsync: (state: Partial<ToastListState>) => Promise<void>;
        context: unknown;
        setState<K extends keyof ToastListState>(state: ToastListState | ((prevState: Readonly<ToastListState>, props: Readonly<ToastListProps>) => ToastListState | Pick<ToastListState, K>) | Pick<ToastListState, K>, callback?: () => void): void;
        forceUpdate(callback?: () => void): void;
        readonly props: Readonly<ToastListProps>;
        state: Readonly<ToastListState>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ToastListProps>, prevState: Readonly<ToastListState>): any;
        componentDidUpdate?(prevProps: Readonly<ToastListProps>, prevState: Readonly<ToastListState>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ToastListProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ToastListProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): void;
    };
    ref: {
        stack: boolean;
        innerWrapperRef: React.RefObject<HTMLDivElement>;
        readonly adapter: ToastListAdapter;
        handleMouseEnter: (e: React.MouseEvent<Element, MouseEvent>) => void;
        handleMouseLeave: (e: React.MouseEvent<Element, MouseEvent>) => void;
        has(id: string): any;
        add(opts: ToastInstance): any;
        update(id: string, opts: ToastInstance): any;
        remove(id: string): any;
        destroyAll(): any;
        render(): React.JSX.Element;
        cache: any;
        foundation: any;
        componentDidMount(): void;
        componentWillUnmount(): void;
        isControlled: (key: any) => boolean;
        log(text: string, ...rest: any): any;
        getDataAttr(props?: any): {};
        setStateAsync: (state: Partial<ToastListState>) => Promise<void>;
        context: unknown;
        setState<K extends keyof ToastListState>(state: ToastListState | ((prevState: Readonly<ToastListState>, props: Readonly<ToastListProps>) => ToastListState | Pick<ToastListState, K>) | Pick<ToastListState, K>, callback?: () => void): void;
        forceUpdate(callback?: () => void): void;
        readonly props: Readonly<ToastListProps>;
        state: Readonly<ToastListState>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ToastListProps>, prevState: Readonly<ToastListState>): any;
        componentDidUpdate?(prevProps: Readonly<ToastListProps>, prevState: Readonly<ToastListState>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ToastListProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ToastListProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ToastListProps>, nextState: Readonly<ToastListState>, nextContext: any): void;
    };
    useToast: typeof useToast;
    defaultOpts: ToastReactProps & {
        motion: boolean;
    };
    propTypes: {
        content: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        duration: PropTypes.Requireable<number>;
        onClose: PropTypes.Requireable<(...args: any[]) => any>;
        icon: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        direction: PropTypes.Requireable<string>;
        stack: PropTypes.Requireable<boolean>;
    };
    defaultProps: {};
    wrapperId: string;
    create(opts: ToastReactProps): string;
    close(id: string): void;
    destroyAll(): void;
    getWrapperId(): string;
    info(opts: string | Omit<ToastReactProps, "type">): string;
    warning(opts: string | Omit<ToastReactProps, "type">): string;
    error(opts: string | Omit<ToastReactProps, "type">): string;
    success(opts: string | Omit<ToastReactProps, "type">): string;
    config(opts: ConfigProps): void;
    contextType?: React.Context<any>;
};
export default _default;
