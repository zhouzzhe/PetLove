"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.empty = empty;
exports.forwardStatics = forwardStatics;
exports.get = get;
exports.has = has;
exports.remove = remove;
exports.set = set;
var _isObject2 = _interopRequireDefault(require("lodash/isObject"));
var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));
var _values2 = _interopRequireDefault(require("lodash/values"));
var _unset2 = _interopRequireDefault(require("lodash/unset"));
var _toPath2 = _interopRequireDefault(require("lodash/toPath"));
var _has2 = _interopRequireDefault(require("lodash/has"));
var _set2 = _interopRequireDefault(require("lodash/set"));
var _get2 = _interopRequireDefault(require("lodash/get"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const pathToArrayElem = path => {
  const pathArray = (0, _toPath2.default)(path);
  // internal-issues:673
  const justNumber = (0, _isNumber2.default)(path) && pathArray.length === 1;
  return justNumber ? false : Number.isInteger(+pathArray[pathArray.length - 1]);
};
function isEmptyObject(target) {
  /**
   *  var a = {};
   *  var b = { c: undefined }
   *  var d = {
   *      e: function(){},
   *      f: Symbol(''),
   *  }
   *  the result of JSON.stringify(a/b/d) are same: '{}'
   *  We can use the above features to remove keys with empty values in Form
   *  But we cannot use JSON.stringify() directly, because if the input parameter of JSON.stringify includes fiberNode, it will cause an TypeError: 'Converting circular structure to JSON'
   *  So we have to mock it's behavior, also, the form value cannot have Symbol or function type, it can be ignored
   */
  if (!(0, _isObject2.default)(target)) {
    return false;
  } else {
    const valuesOfTarget = (0, _values2.default)(target);
    // values(a)  ->   []
    // values(b)  ->   [undefined]
    if (!valuesOfTarget.length) {
      return true; // like target: {}
    } else {
      return valuesOfTarget.every(item => typeof item === 'undefined');
    }
  }
}
function cleanup(obj, path) {
  let pull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (path.length === 0) {
    return;
  }
  const target = (0, _get2.default)(obj, path);
  // remove undefined from array
  // if (Array.isArray(target) && pull) {
  //     // only remove undefined form array from right to left
  //     // Remove undefined from right to left
  //     let lastIndex = findLastIndex(target, item => !isUndefined(item));
  //     lodashRemove(target, (value, index, array) => index > lastIndex);
  // }
  // Delete object if its empty
  if (Array.isArray(target) && target.every(e => e == null)) {
    (0, _unset2.default)(obj, path);
  } else if (isEmptyObject(target)) {
    (0, _unset2.default)(obj, path);
  }
  // Recur
  cleanup(obj, path.slice(0, path.length - 1), pull);
}
function empty(object) {
  return (0, _values2.default)(object).length === 0;
}
function get(object, path) {
  return (0, _get2.default)(object, path);
}
function remove(object, path) {
  (0, _unset2.default)(object, path);
  // a.b => [a, b]
  // arr[11].a => [arr, 11, a]
  let pathArray = (0, _toPath2.default)(path);
  pathArray = pathArray.slice(0, pathArray.length - 1);
  cleanup(object, pathArray, false);
}
function set(object, path, value, allowEmpty) {
  if (allowEmpty) {
    return (0, _set2.default)(object, path, value);
  }
  if (value !== undefined) {
    return (0, _set2.default)(object, path, value);
  } else {
    // If the path is to an array leaf then we want to set to undefined
    // 将数组的叶子节点置为undefined时，例如 a.b[0]  a.b[1]  a.b[99]
    if (pathToArrayElem(path) && get(object, path) !== undefined) {
      (0, _set2.default)(object, path, undefined);
      let pathArray = (0, _toPath2.default)(path);
      pathArray = pathArray.slice(0, pathArray.length - 1);
      cleanup(object, pathArray, false);
    } else if (!pathToArrayElem(path) && get(object, path) !== undefined) {
      // Only delete the field if it needs to be deleted and its not a path to an array ( array leaf )
      // eg:
      /*
          When the non-array leaf node is set to undefined
          for example: a.b.c
      */
      remove(object, path);
    }
  }
}
function has(object, path) {
  return (0, _has2.default)(object, path);
}
/**
 * set static properties from `srcObj` to `obj`
 * @param {object|Function} obj
 * @param {object|Function} srcObj
 * @returns {object|Function}
 */
function forwardStatics(obj, srcObj) {
  if (obj && (typeof obj === 'function' || typeof obj === 'object') && srcObj && (typeof srcObj === 'function' || typeof srcObj === 'object')) {
    Object.entries(srcObj).forEach(_ref => {
      let [key, value] = _ref;
      obj[key] = value;
    });
  }
  return obj;
}